{% extends 'base.html' %}
{% load static %}
{% load widget_tweaks %}
{% block title %} Project {% endblock %}
{% block content %}



<header id="gtco-header" class="gtco-cover gtco-cover-sm" role="banner" style="background-image: url({% static 'website/images/img_project_main.jpg' %})">
  <div class="overlay"></div>
  <div class="gtco-container">
    <div class="row">
      <div class="col-md-12 col-md-offset-0 text-left">
        <div class="row row-mt-15em">
          <div class="col-md-7 mt-text animate-box" data-animate-effect="fadeInUp">
            <span class="intro-text-small">Learn how we developed 'Mileage'</span>
            <h1>The Project</h1>
          </div>
        </div>
      </div>
    </div>
  </div>
</header>
<div class="gtco-section">
    <div class="gtco-container">
      <div class="row">
        <div class="text-center gtco-heading">
          <br>
          <br>
          <h2>Website under construction!</h2>
          <h2>Introducción</h2>
          
          <p align="justify">Mileage es un trabajo fin de máster en big data y data Science de cinco alumnos de la Universidad Complutense de Madrid que tiene como objetivo generar predicciones acerca del valor de vehículos dadas ciertas características de los mismos.</p>
          
          <p align="justify">El equipo lo forman Alvaro Lozano, Andrea Lizondo, Mario Muriel, Pablo Abad y Pablo Casero.</p>
          
          <p align="justify">La motivación para realizar dicho proyecto fue la de poner en práctica los conocimientos adquiridos durante el curso para desarrollar una herramienta completamente funcional. Con este proyecto, el equipo ha querido retarse a si mismo, expandiendo sus límites y buscando soluciones para todos los problemas que han ido surgiendo, con el fin de prepararse para un entorno profesional de ciencia de datos.</p>
          
          <p align="justify">En el plano organizativo, se ha seguido una estrategia que trata de abordar primero aquellas fases que planteaban más problemas al equipo, progresando desde soluciones sencillas hasta las más complejas implementadas en el proyecto final. Esta forma de trabajar permitía al equipo tener un control absoluto, en la forma que habiendo solucionado los problemas al principio se garantizaba la ausencia de grandes trabas para alcanzar el objetivo final.</p>
          
          <p align="justify">Debido a diversos factores como la pandemia por la COVID-19, el hecho de que la mayoría de los compañeros tuviesen que compaginar el trabajo con los estudios y que la liberación del TFM se realizase próxima al período vacacional, el trabajo en equipo planteaba un reto importante. El equipo ha estado a la altura para sobreponerse a todas las dificultades y la organización en este aspecto ha sido inmejorable. Gracias a plataformas colaborativas el equipo ha podido ir trabajando de forma conjunta en todo momento, con reuniones periódicas, aprovechando los puntos fuertes de cada uno y aprendiendo entre nosotros.</p>
          
          <p align="justify">Para la realización del proyecto se han utilizado varios recursos, como Google Cloud Platform (instancia de AI Notebooks), Kaggle, Kaggle Kernel, Google Collaboratory, Django y Github entre otros. El principal lenguaje de programación utilizado ha sido Python, aunque también R, SQL, HTML, Javascript, CSS o Bash.</p>
          <div class="contain-img">
            <img src="{% static 'website/images/img_project_gcp2.png' %}" alt="Mileage google cloud platform">
            <figcaption>Fig.X - Google Cloud Platform - AI Notebook - M76</figcaption>
          </div>
          

          <br><br><h2>Importación de los datos</h2>
          <p align="justify">La primera fase del proyecto es la importación u obtención del conjunto de datos. Tras contemplar distintas opciones, se decidió apostar por el dataset de Kaggle llamado “US used cars data” (https://www.kaggle.com/ananaymital/us-used-cars-dataset) puesto que ofrece una buena cantidad de registros (3 millones) y un gran número de variables que confiere al conjunto de datos bastante flexibilidad.</p>
          <div class="contain-img">
            <img src="{% static 'website/images/img_project_dataset.png' %}" alt="Mileage Dataset">
            <figcaption>Fig.X - Kaggle - Us used cars dataset</figcaption>
          </div>

          <br><br><h2>Análisis exploratorio de los datos</h2>
          <p align="justify">La segunda fase consistía en la verificación de la calidad de los datos para asegurar que los mismos son lo suficientemente buenos como para generar conclusiones y resultados. Incluyendo en esta parte el EDA. </p>

          <br><br><h2>Transformación de los datos</h2>
          <p align="justify">En la tercera fase se ejecutó la limpieza de los datos, así como el feature engineering. Se eliminaron las variables con un porcentaje de valores nulos o incorrectos que superaban un determinado umbral, variables repetidas, así como aquellas con un poder de predicción nulo o cuasi nulo. También se realizaron cambios en los tipos de algunas variables, eliminación de las unidades junto al valor de la variable o imputación de valores nulos.</p>

          <p align="justify">Entre las partes más destacables de este proceso se encuentra la eliminación de registros en los que la variable faltante era de imperiosa necesidad. Véase el caso de la variable que indica el kilometraje (en millas) del vehículo, 'mileage'. Este paso dejó unas perdidas de casi 150.000 registros, lo que suponía un 5% del total del conjunto de datos. Sin embargo, una pérdida asumible y justificada.</p>

          <div class="col-md-12 col-md-offset-0 text-left">
            <link rel="stylesheet"
                  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/obsidian.min.css">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
            <script>hljs.initHighlightingOnLoad();</script>
              <body>
                <pre><code class="python">
                    cars = cars.dropna(subset=['mileage'])

                    perc = round(cars.isnull().sum() * 100 / len(cars))
                    count = cars.isnull().sum()
                    nas = pd.concat([nas, perc, count], axis=1)
                    del perc
                    del count
                    nas.columns = ["percentage_0", "count_0", "percentage_1", "count_1"]
                    nas.sort_values(by=["percentage_0", "count_0"])
                  </code></pre>
              </body>
            </div>
            <div class="contain-img">
              <img src="{% static 'website/images/redim.png' %}" alt="Mileage Dataset">
              <figcaption>Fig.X - Kaggle - Us used cars dataset</figcaption>
            </div>

          <p align="justify">Para el resto de variables se siguió una estrategia de imputación bastante fiable y que ofrecía muy buenos resultados. Gracias a la naturaleza de los datos y al conocimiento/estudio en el área de la automoción, nos fue posible determinar que combinación de variables definían de forma intrínseca otras variables. Sirva como ejemplo que para determinar el número de asientos de un vehículo basta con conocer marca, modelo y tipo de carrocería. No se descarta que puntualmente pueda haber excepciones, pero se asume el riesgo y como se ha mencionado anteriormente, esta estrategia mejoraba el modelo de forma considerable.</p>

          <div class="col-md-12 col-md-offset-0 text-left">
            <link rel="stylesheet"
                  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/obsidian.min.css">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
            <script>hljs.initHighlightingOnLoad();</script>
              <body>
                <pre><code class="python">
                    # "maximum_seating" debería ser de las más fáciles de imputar. Solo necesitamos 
                    # saber "make_name", "model_name" y "body_type" y en principio debería bastar.
                    cars["avg_maximum_seating"] = cars.groupby(["make_name", "model_name", "body_type"])
                    ["maximum_seating"].transform("mean")

                    # Imputación city_fuel_economy. Características que definen el consumo de un coche: 
                    # "body_type", "engine_displacement", "engine_type", "fuel_type", "horsepower", 
                    # "make_name", "model_name", "transmission", "wheel_system", "year"
                    cars["avg_city_fuel_economy"] = cars.groupby(["body_type", "engine_displacement", 
                    "engine_type", "fuel_type", "horsepower", "make_name", "model_name",  
                    "year"])['city_fuel_economy'].transform('mean')

                    # Lo mismo para highway_fuel_economy
                    cars["avg_highway_fuel_economy"] = cars.groupby(["body_type", "engine_displacement", 
                    "engine_type", "fuel_type", "horsepower", "make_name", "model_name",  "year"])
                    ['highway_fuel_economy'].transform('mean')

                    # "horsepower" y "engine_displacement" tienen el mismo número de NAs, por lo que 
                    # suponemos que son las mismas filas. No podemos utilizar una variable para
                    # imputar la otra, así que utilizaremos el resto.
                    cars["avg_horsepower"] = cars.groupby(["engine_type", "fuel_type", "make_name", 
                    "model_name",  "year"])['horsepower'].transform('mean')
                    cars["avg_engine_displacement"] = cars.groupby(["engine_type", "fuel_type", 
                    "make_name", "model_name",  "year"])['engine_displacement'].transform('mean')

                    # "fuel_tank_volume" dependerá de la marca, modelo y año.
                    cars["avg_fuel_tank_volume"] = cars.groupby(["make_name", "model_name",  "year"])
                    ['fuel_tank_volume'].transform('mean')

                    # Sustitución de los valores NA
                    cars['maximum_seating'] = np.where(cars['maximum_seating'].isna(), cars['avg_maximum_seating'], 
                    cars['maximum_seating'])
                    cars['city_fuel_economy'] = np.where(cars['city_fuel_economy'].isna(), cars['avg_city_fuel_economy'], 
                    cars['city_fuel_economy'])
                    cars['highway_fuel_economy'] = np.where(cars['highway_fuel_economy'].isna(), cars['avg_highway_fuel_economy'], 
                    cars['highway_fuel_economy'])
                    cars['horsepower'] = np.where(cars['horsepower'].isna(), cars['avg_horsepower'], cars['horsepower'])
                    cars['engine_displacement'] = np.where(cars['engine_displacement'].isna(), cars['avg_engine_displacement'], 
                    cars['engine_displacement'])
                    cars['fuel_tank_volume'] = np.where(cars['fuel_tank_volume'].isna(), cars['avg_fuel_tank_volume'], 
                    cars['fuel_tank_volume'])
                    cars = cars.drop(['avg_maximum_seating', 'avg_city_fuel_economy', 'avg_highway_fuel_economy', 'avg_horsepower', 
                    'avg_engine_displacement', 'avg_fuel_tank_volume'], axis=1)
                  </code></pre>
              </body>
            </div>


          <p align="justify">Tras una primera fase de imputaciones para variables contínuas y categóricas por el método descrito, se procedió a una segunda fase de imputaciones para aquellos registros que no habían podido ser imputados (sirva otra vez el ejemplo anterior: en el caso de faltar una, o varias, de las tres variables (marca, modelo o tipo de carrocería) no podría imputarse el número de plazas del vehículo. En esta segunda fase se prescindió de algunas variables para imputar los valores ausentes. No obstante, tras realizar diversas pruebas con ello, se determinó que esta segunda fase no era una buena estrategia y se descartó.</p>

          <p align="justify">Tras el fallo del método anterior, se procedió a realizar imputaciones numéricas utilizando la media, pero sin duda se obtuvieron peores resultados. Finalmente se optó por eliminar los registros que no podían ser imputados a través de otras variables. Esta decisión se tomó en base a los distintos resultados obtenidos en varios modelos con distintas estrategias de imputación.</p>

          <p align="justify">Nótese que en ningún momento se utiliza la variable que identifica el valor de mercado de un vehículo para imputar otras, puesto que esto supondría un claro caso de data leakage.</p>

          <p align="justify">Hubo también que realizar correcciones para los vehículos eléctricos, ya que sus características mecánicas difieren mucho de aquellas de un vehículo de motor térmico y por tanto eran un caso especial que había que tratar con especial atención.</p>

          <div class="col-md-12 col-md-offset-0 text-left">
            <link rel="stylesheet"
                  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/obsidian.min.css">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
            <script>hljs.initHighlightingOnLoad();</script>
              <body>
                <pre><code class="python">
                    # Los vehículos eléctricos son algo especiales y tienen muchos datos perdidos
                    cars.loc[cars["fuel_type"] == "Electric", "engine_type"] = "Electric_Motor" 
                    cars.loc[cars["fuel_type"] == "Electric", "transmission_display"] = 1 # los vehículos 
                    #eléctricos no tienen marchas
                    cars.loc[cars["fuel_type"] == "Electric", "horsepower"] = cars.horsepower.mean() # Solo hay 1 vehículo 
                    #eléctrico cuyo valor de esta variable no sea NA
                    cars.loc[cars["fuel_type"] == "Electric", "engine_displacement"] = cars.engine_displacement.mean()
                    cars.loc[cars["fuel_type"] == "Electric", "fuel_tank_volume"] = cars.fuel_tank_volume.mean()
                  </code></pre>
              </body>
          </div>
          

          <p align="justify">Otra fase del procesado consistía en la recodificación por distintos motivos. A veces para agrupar valores que tenían el mismo sentido pero distinto valor, o a veces por el simple hecho de convertirlas en variables cómodas para el usuario final.</p>

          <p align="justify">Una vez obtenido un dataset limpio e interpretable se estructuró y organizó en la forma que sería utilizado finalmente por el usuario y se extrajo un archivo JSON para poder ser utilizado más tarde en la aplicación web para filtrar opciones de configuración de un vehículo.</p>

          <div class="col-md-12 col-md-offset-0 text-left">
            <link rel="stylesheet"
                  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/obsidian.min.css">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
            <script>hljs.initHighlightingOnLoad();</script>
              <body>
                <pre><code class="python">
                    web_dic = cars.drop_duplicates(subset=["make_name", "model_name", "body_type", 
                                       "fuel_type", "transmission", "horsepower",
                                       "engine_displacement", "engine_type", 
                                       "wheel_system", "transmission_display", "year",
                                       "fuel_tank_volume", "city_fuel_economy", 
                                       "highway_fuel_economy", "maximum_seating"])[["make_name", 
                                                                                    "model_name",
                                                                                    "body_type",
                                                                                    "fuel_type",
                                                                                    "transmission",
                                                                                    "horsepower",
                                                                                    "engine_displacement", 
                                                                                    "engine_type",
                                                                                    "wheel_system",
                                                                                    "transmission_display", 
                                                                                    "year",
                                                                                    "fuel_tank_volume",
                                                                                    "city_fuel_economy",
                                                                                    "highway_fuel_economy",
                                                                                    "maximum_seating"]].sort_values
                                                                                          (by=["make_name", 
                                                                                              "model_name",
                                                                                              "body_type",
                                                                                              "fuel_type",
                                                                                              "transmission",
                                                                                              "horsepower",
                                                                                              "engine_displacement", 
                                                                                              "engine_type",
                                                                                              "wheel_system",
                                                                                              "transmission_display", 
                                                                                              "year",
                                                                                              "fuel_tank_volume",
                                                                                              "city_fuel_economy",
                                                                                              "highway_fuel_economy",
                                                                                              "maximum_seating"])
                    result = web_dic.to_json(orient="records")
                    web_dic.to_json(r'/home/jupyter/imported/web_dic3', orient="records")
                  </code><figcaption>Fig.X - Jupyter Notebook - Creating and saving JSON file from cleaned dataset</figcaption></pre>
              </body>
          </div>

          <p align="justify">El siguiente paso en la preparación del conjunto de datos consistía en la transformación de las variables categóricas de forma que el modelo pudiese operar con ellas. Para ello se conviertieron dichas variables a dummies.</p>

          <br><br><h2>Modelización</h2>
          <p align="justify">Ya preparado el conjunto de datos, se procedió al particionado de los mismos, utilizando un 80% de ellos para entrenar el modelo y el 20% restante para evaluarlo. El modelo utilizado fue un regresor de la librería CatBoost. Habiendo establecido una semilla y cambiando un parámetro a la vez, se probaron distintas configuraciones para determinar cual era el mejor modelo.</p>

          <p align="justify">Tras haber obtenido el mejor modelo, se extrajo el archivo 'pickle' para poder ser utilizado más tarde en la aplicación web.</p>

          <br><br><h2>Evaluación</h2>
          <p>...</p>

          <br><br><h2>Implantación</h2>
          <p align="justify">Tras todo el proceso anterior, en el que se obtiene un modelo con buenos resultados a partir de un dataset en crudo, llega el proceso en el cual se implanta el modelo en una aplicación para que pueda ser utilizada por el usuario final. Para su implantación se utiliza Django, que es un framework de desarrollo web de código abierto, escrito en Python, que respeta el patrón de diseño conocido como modelo–vista–controlador.</p>
          <p align="justify">Utilizando Django se genera una aplicación con una interfaz visual atractiva y sencilla de manejar por un usuario cualquiera sin conocimientos en ciencia de datos o programación.</p>
          <p align="justify">La aplicación se encuentra en un servidor en linea gracias a Heroku, que es una plataforma como servicio de computación en la Nube que soporta distintos lenguajes de programación.</p>
          <p align="justify">Funcionamiento de la aplicación: En el servicio en linea, a través de desplegables dependientes en cascada se seleccionan las características que definen los vehículos gracias a que el archivo .JSON extraído del conjunto de datos se encuentra alojado en el servidor. Una vez seleccionadas todas las características, se ejecuta la acción de calcular, entonces, la aplicación utiliza el archivo pickle, en el que está guardado el algoritmo del modelo, para estimar el valor de mercado del vehículo. La aplicación luego devuelve la estimación junto a las características introducidas de forma que se puedan verificar los parámetros introducidos.</p>
          <p align="justify">Asimismo, la </p>

          <div class="col-md-12 col-md-offset-0 text-left">
            <link rel="stylesheet"
                  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/obsidian.min.css">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
            <script>hljs.initHighlightingOnLoad();</script>
              <body>
                <pre>
                  <code class="python">
                    threshold = 30
                    columns = cars.isnull().sum() * 100 / len(cars) > threshold
                    cars = cars[columns.index[~columns]]
                    del columns
                    #...#
                    cars = cars.drop(['daysonmarket', 'latitude', 'listing_id', 'longitude', 'sp_id'], axis=1)
                  </code>
                </pre>
              </body>
          </div>
          <p>Se cambiaron también algunos tipos de datos y se limpiaron las unidades que acompañaban a los valores numéricos.</p>

          <h2>Borrador. Ni caso a lo de debajo.</h2>
          <p>Mileage es un proyecto que tiene su origen en la necesidad de cubrir una necesidad en el ambito del mercado de vehículos de segunda mano. Calcular el precio de venta de un vehículo puede ser bastante complejo para muchas personas. En el mejor de los casos, la persona invertirá mucho tiempo estudiando el mercado a base de consultar uno y otro anuncio de vehículos similares al suyo. En el peor de los casos, la persona acabará en un servicio de tasación de vehículos, el cual le pedirá información personal antes de facilitarle la tasación de su vehículo. Dicho servicio le facilitará una tasación muy por debajo del valor de mercado de su vehículo para luego intentar comprárselo. Este no es un requisito banal, puesto que el negocio de estos servicios reside en la intermediación.</p>
          <p>Mileage es un proyecto de carácter académico que simula una aplicación web que ofrece un servicio gratuito de predición del precio de vehículos de segunda mano. La predicción se realiza a partir de un modelo de machine learning a partir de un dataset de 3 millones de registros extraídos en septiembre de 2020 de Cargurus, una página web estadounidense de compraventa de vehículos.</p>
          <p>El proyecto ha sido realizado por Alvaro Lozano, Andrea Lizondo, Mario Muriel, Pablo Abad y Pablo Casero.</p>
          <p>La motivación para realizar el proyecto vino de querer aplicar gran parte de los conocimientos adquiridos en el máster, llevando a cabo el proceso completo desde la obtención del dataset hasta la productivización en un modelo de negocio.</p>
          <h2>Realización</h2>
          <p>Tras la valoración diversas ideas, se eligió dar vida al proyecto da El proyecto nace de un dataset público en Kaggle, llamado "US used cars dataset". 
          </p>


      

      <body>
        <pre><code class="python">
        def fib(n):
        a, b = 0, 1
          while a < n:
            print(a, end=' ')
            a, b = b, a+b
            print()
        fib(1000)

        # Una vez quitadas aquellas variables con gran cantidad de NAs, quitamos aquellos registros que tengan algún NA.
        s1 = cars.shape[0]
        cars = cars.dropna()
        del_na = s1 - cars.shape[0]
        print("Se han eliminado {} filas".format(del_na))

        del del_na
        del s1

        dic_transmission = {"A": "Automatic Transmission (A)", "CVT": "Continuously Variable Transmission (CVT)", 
                    "Dual Clutch": "Dual Clutch Transmission (DCT)", "M": "Manual Transmission (M)"}
        cars["transmission"].replace(dic_transmission, inplace=True)
        del dic_transmission

        dic_engine_type = {"I2": "Inline 2 cylinder", "I3": "Inline 3 cylinder", "I4": "Inline 4 cylinder", 
                           "I5": "Inline 5 cylinder", "I6": "Inline 6 cylinder", "R2": "Rotary Engine", "Electric_Motor": "Electric Motor",
                           "H4": "Boxer 4 cylinder", "H6": "Boxer 6 cylinder"}
        cars["engine_type"].replace(dic_engine_type, inplace=True)
        del dic_engine_type

        dic_wheel_system = {"FWD": "Forward Wheel Drive (FWD)", "AWD": "All Wheel Drive (AWD)", "4WD": "Four Wheel Drive (4WD)", "RWD": "Rear Wheel Drive (RWD)",
                            "4X2": "Two Wheel Drive (4X2)"}
        cars["wheel_system"].replace(dic_wheel_system, inplace=True)
        del dic_wheel_system

        dic_listing_color = {"WHITE": "White", "BLACK": "Black", "SILVER": "Silver", "UNKNOWN": "Unknown", "GRAY": "Gray", "BLUE": "Blue", "RED": "Red",
                             "GREEN": "Green", "BROWN": "Brown", "ORANGE": "Orange", "GOLD": "Gold", "TEAL": "Teal", "YELLOW": "Yellow", "PURPLE": "Purple",
                             "PINK": "Pink"}
        cars["listing_color"].replace(dic_listing_color, inplace=True)
        del dic_listing_color



        # Quitamos las variables que no tienen sentido y que dificilmente vamos a utilizar en el proyecto en ningún momento.
        cars = cars.drop(['daysonmarket', 'latitude', 'listing_id', 'longitude', 'sp_id'], axis=1)

        # Quitamos también otras variables que quizá si que utilicemos más adelante, pero de momento, fuera.
        cars = cars.drop(['vin', 'city', 'dealer_zip', 'description', 'listed_date', 'main_picture_url', 'major_options', 'power', 
        'savings_amount', 'sp_name', 'torque', 'trim_name', 'trimId', 'wheel_system_display'], axis=1)

        # Limpiando de variables que no debería meter en la web
        cars = cars.drop(['back_legroom', 'franchise_dealer', 'front_legroom', 'height', 'length', 'seller_rating', 'wheelbase', 
        'width', 'franchise_make', 'interior_color', 'exterior_color'], axis=1)

        # Dropeo engine_cylinders porque parece igual que engine_type
        cars = cars.drop(['engine_cylinders'], axis=1)
      </code></pre>
      </body>
    </div>

          <h2>The Thesis</h2>
                  <p>The goals of this project are not precisely defined yet. We can easily achieve the requirements to get a passing score, but we want to challenge ourselves and see how far we can go now.</p>
                  <p>Building a regression model that predicts the price of a car using a dataset of 3 million rows and 66 columns would be laborious but easy, so we decided to go further.</p>
                  <p>Before we complete any of the parts of the project, we have to be sure that we can accomplish them, that is the project is a bit chaotic right now, but it is under control.</p>
                  <div class="contain-img">
                    <img src="{% static 'website/images/img_project_relleno_1.jpg' %}" alt="My image comment">
                  </div>
                <br>
                <h2>The Model</h2>
                  <p>Using Google Cloud we have built an initial model (catboost) that we want to improve.</p>
                  <p>We will also try to apply models such as Lasso, Elasticnet, Ensemble (gradient boosting) or even KNN if possible.</p>
                  <p>If possible, we will perform another model that, given a period of time (within the customer wants to sell the car), the model will output a prediction.</p>
                  <p>Imagine a customer that is in a hurry and needs the money ASAP. The model will output a price with a maximized benifit within a month. If the customer wants to get as much as possible,</p>
                  <p> the model will consider (for example) a period of six months and will output a higher price.</p>
                  <div class="contain-img">
                    <img src="{% static 'website/images/img_project_relleno_2.jpg' %}" alt="My image comment">
                  </div>
                <br>
                <h2>The Website</h2>
                  <p>The website is not a requirement in our thesis at all, but deploying models is something we want to learn and we thought it would be a good idea to do it now. Moreover, we are learning new technologies and languages.</p>
                  <p>Last week we knew barely nothing about CSS, HTML, Javascript or Django, and after a couple of days we were able to build the website. </p>
                  <p>The structure of the website will (probably) be:</p>
                  <p>The home page, with a little information about our "company", the model... and a "catchy" appearance.</p>
                  <p>A team section with a description of us.</p>
                  <p>The project section will consist of the "presentation" of the project. We will be using it during our presentation of the project instead of a PPT document. -So... it will be completely different as you can see it now.</p>
                  <p>The model section. The main page form will redirect here. There will be a form to fulfill with car specs so that the model predicts the price.</p>
                  <p>We still have a lot to do in that model because we want to improve the user experience of the form.</p>
                  <p>We are considering the option of integrating some intereactive visualizations, if possible, with tableau. But we are still thinking how to integrate it. It needs to make sense...</p>
                  <br>
                  <p>So, this is a little presentation of what we are doing. Thank you for your time!!!</p>
                  <p>The team</p>
                  <div class="contain-img">
                    <img src="{% static 'website/images/img_project_relleno_3.jpg' %}" alt="My image comment">
                  </div>
        </div>
      </div>
      <div class="row">
      </div>
    </div>
  </div>

{% endblock %}	